# 4. Weilding functions

## 4.1 Anonymous functions
* Anonymous functions are typically used in cases where we wish to create a function for later use, such as storing it in a variable, establishing it as a method of an object, or using it as a callback
* Functions are much more ethereal; they're frequently defined as needed, and discarded just as quickly
* Functional programming concentrates on small, usually side-effect-free, functions as the basic building blocks of application code

## 4.2 Recursion
* Whenever a function calls itself, or calls a function that in turn calls the original function anywhere in the call tree, recursion occurs

### 4.2.1 Recursion in named functions

### 4.2.2 Recursion with methods

### 4.2.3 The pilfered reference problem

### 4.2.4 Inline named functions
* Nothing wrong with giving *any* function literal a name, even those that are declared as callbacks or methods
* No longer *anonymous*, these functions are better called *inline functions*

### 4.2.5 The callee property

## 4.3 Fun with function as objects

### 4.3.1 Storing functions

### 4.3.2 Self-memoizing functions
* *Memoization* is the process of building a function that's capable of remembering its previously computed values
* Can markedly increase performance by avoiding needless complex computations that have already been performed

* Memoizing expensive computations
* 2 major advantages
    * Enjoys performance benefits for function calls
    * Happens completely seamlessly and behind the scenes
* Disadvantages
    * Consume more memory
    * Mixed logic with business logic
    * Difficult to load-test or measure the performance
    
* Memoizing DOM elements

### 4.3.3 Faking array methods

## 4.4 Variable-length argument lists
* Function can accept an arbitrary number of arguments
* Key to implement overloading

### 4.4.1 Using apply() to supply variable arguments

### 4.4.2 Function overloading
* Detecting and traversing arguments
* The ability to access and traverse the `arguments` collection is a powerful mechanism for creating complex and intelligent methods
* Use it to inspect the arguments passed to any function in order to allow our function to flexbility operate on the arguments

* Slicing and dicing an arguments list

* Function overloading approaches

* The function's length property
* function's length equates to the number of named parameters with which the function was declared
* Via the function's length property, know how many maned parameters it was declared with
* Via `arguments.length`, know how many arguments passed on the invocation

* Overloading functions by argument count
```
var ninja = {
    whatever: function() {
        switch (arguments.length) {
            case 0:
                // do something
                break;
            case 1:
                // do something else
                break;
            case 2:
                // do something else
                break;
        }
    }
}
```
* The overloading only works for different numbers of arguments
* Such overloaded methods will have some function call overhead

## 4.5 Checking for functions
```
function isFunction(fn) {
    return Object.prototype.toString.call(fn) === '[object Function]';
}
```

## 4.6 Summary
* Anonymous functions let us create smaller units fo execution rather than large functions fill of imperative statements
* Looking at recursive functions, we learned how functions can be referenced in various ways
    * By name
    * As a method
    * By an inline name
    * Through the `callee` property of `arguments`
* Functions can have properties and those properties can be used to store any information we might wish to use
    * Storing functions in function properties
    * Using function properties to create a cache
* Functions can perform different operations based upon the arguments that are passed to it
* An object can be checked to see if it's an instance of a function by testing if the result of the `typeof` operator is a "function"