# 2. Arming with testing and debugging

## 2.1 Debugging code
* Firebug
* IE Developer Tools
* Opera Dragonfly
* WebKit Developer Tools

## 2.1.1 Logging
* Logging statements (such as using the `console.log()` method) are part of the code and are useful in a cross-browser sense
```
function log() {
    try {
        console.log.apply(console, arguments);
    } catch (e) {
        try {
            opera.postError.apply(opera, arguments);
        } catch (e) {
            alert(Array.prototype.join.call(arguments, " ");
        }
    }
}
```

## 2.1.2 Breakpoints
* Halt the execution of a script at a specific line of code, pausing the browser
* Allow us to leisurely investigate the state of all sorts of things at the point of the break
* Includes all accessible variables, the context, and the scope chain

## 2.2 Test generation
* Good tests make good code
* Good tests exhibit 3 important characteristics
    * *Repeatability* - our tests results should be highly reproducible. Test run repeatedly should always produce the exact same results
    * *Simplicity* - our tests should focus on testing one things
    * *Independence* - our tests should execute in isolation. Must avoid making the results from one test dependent upon another. Breaking tests down into the smallest possible units will help us determine the exact source of a bug when an error occurs
    
* 2 primary approaches for constructing tests
    * *Deconstructive test cases* - test cases are created when existing code is whittle down (deconstructed) to isolate problem, eliminating anything that's not germane to the issue
    * *Constructive test cases* - start from a known good, reduced case and build up until we are able to reproduce the bug in question

## 2.3 Testing frameworks
* Test suite should serve a single need: displaying the results of the tests, making it easy to determine which tests have passed or failed

## 2.4 The fundamentals of a test suite
* The primary purpose of a test suite is to aggregate all the individual tests that your code base might have into a single unit, so that they can be run in bulk, providing a single resource that can be run easily and repeatedly

### 2.4.1 The assertion
* The core of a unit-testing framework it its assertion method, usually named `assert()`

### 2.4.2 Test groups
* Simple assertions are useful, but they really begin to shine when they're grouped together in a testing context to form *test groups*
* When performing unit testing, a test group will likely represent a collection of assertions as they relate to a single method in our API or application
* Beyond simple testing of code, another important aspect of a testing framework is the handling of asynchronous operations

## 2.4.2 Asynchronous testing
* Tests whose results will come back *after* a non-deterministic amount of time has passed; common examples of this situation are Ajax requests and animations
* To handle asynchronous tests, we need to follow a couple of simple steps:
    * Assertions that rely upon the same asynchronous operation need to be grouped into a unifying test group
    * Each test group needs to be placed on a queued to be run after all the previous test groups have finished running
    
## 2.6 Summary
* Use logging to observe the action of our code as it's running
* Use breakpoints to halt the execution of our code at a certain point
* Attributes of good test: *repeatability*, *simplicity* and *independence*