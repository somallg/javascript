# 4. Functions
* Functions are the fundamental modular unit of JavaScript
* Used for code reuse, information hiding, and composition
* Used to specify the behavior of objects
* Generally, the craft of programming is the factoring of a set of requirements into a set of functions and data structures

## 4.1 Function Objects
* Functions in JavaScript are objects
* Objects are collections of name/value pairs having a hidden link to a prototype object
* Object produced from object literals are linked to `Object.prototype`
* Function objects are linked to `Function.prototype` (which is itself linked to `Object.prototype`)
* Every function is also created with two additional hidden properties: the function's context and the code that implements the function's behavior

* Every function object is also created with a `prototype` property
* Its value is an object with a `constructor` property whose value is the function

* Functions can be used like any other value
* Since functions are objects, functions can have methods

* Thing that is special about functions is that they can be invoked

## 4.2 Function Literal
* Function objects are created with function literals
```
var add = function (a, b) {
    return a + b;
}
```

* A function literal has 4 parts
    * Reserved word `function`
    * Function's name (optional)
    * Set of parameters wrapped in parentheses
    * Set of statements wrapped in curly braces

* Function literal can appear anywhere that an expression can appear
    
## 4.3 Invocation
* Invoking a function suspends the execution of the current function, passing control and parameters to the new function
* Every function receives 2 additional parameters: `this` and `arguments`
* `this` determined by the *invocation pattern*
* There are 4 invocation patterns
    * Method invocation pattern
    * Function invocation pattern
    * Constructor invocation pattern
    * Apply invocation pattern
    
* Invocation operator is a pair of parentheses that follow any expression that produce a function value    

## 4.4 The Method Invocation Pattern
* When a function is stored as a property of an object, we call it a *method*
* When a method is invoked, `this` is bound to that object
```
var foo = {
    value: 0,
    add: function(val) {
        this.value += typeof val === 'number' ? val : 1;
    }
};

foo.add();  // value: 1
foo.add(2); // value: 3
```

* A method can use `this` to access the object so that it can retrieve values from the object or modify the object
* The binding of `this` to the object happens at invocation time
* Method that get their object context from `this` are called *public methods*

## 4.5 The Function Invocation Pattern
* When a function is not the property of an object, then it is invoked as a function
```
var sum = add(3, 4);
```

* When a function is invoked with this pattern, `this` is bound to the global object 
* A method cannot employ an inner function to help it do its work because the inner function does not share the method's access to the object as its `this` is bound to the wrong value
* Work around, to store `this` in a variable
```
foo.double = function() {
    var that = this;
    var helper = function() {
        that.value = add(that.value, that.value);
    };
    helper();
};
```

## 4.6 The Constructor Invocation Pattern
* JavaScript is a *prototypal* inheritance language
* That means that objects can inherit properties directly from other objects
* The language is class-free

* If a function is invoked with the `new` prefix, then a new object will be created with a hidden link to the value of the function's `prototype` member, and `this` will be bound to that new object
* The `new` prefix also changes the behavior of the `return` statement
```
var Quo = function(string) {
    this.status = string;
};

Quo.prototype.get_status = function() {
    return this.status;
};

var myQuo = new Quo('hello');
```

* Functions that are intended to be used with the `new` prefix are called `constructors`
* By convention, they are kept in variables with a capitalized name

## 4.7 The Apply Invocation Pattern
* Because JavaScript is a functional object-oriented language, functions can have methods
* The `apply` method lets us construct an array of arguments to use to invoke a function
* It also lets us choose the value of `this`
* The `apply` method takes 2 parameters
    * The value that should be bound to `this`
    * Array of parameters
```
var array = [3, 4];
var sum = add.apply(null, array);

var statusObject = {
    status: 'A-OK'
};

var status = Quo.prototype.get_status.apply(statusObject);
```

## 4.8 Arguments
* A bonus parameter that is available to functions when they are invoked is the `arguments` array
* It gives the function access to all of the arguments that were supplied with the invocation, including excess arguments that were not assigned to parameters
* `arguments` is not really an array. It is an array-like object. It has length property, but it lacks all of the array methods

## 4.9 Return
* When a function is invoked, it begins execution with the first statement, and ends when it hits the } that closes the function body
* The `return` statement can be used to cause the function to return early
* The function always returns a value. If the `return` value is not specified, then `undefined` is returned
* If the function was invoked with the `new` prefix and the `return` value is not an object, then `this` is returned instead

## 4.10 Exceptions
* Exceptions are unusual mishaps that interfere with the normal flow of a program
* When such mishap is detected, your program should throw an exception
```
var add = function (a, b) {
    if (typeof a !== 'number' || typeof b !== 'number') {
        throw {
            name: 'TypeError',
            message: 'add needs number'
        };
    }

    return a + b;
}
```
* Exception object contain
    * `name` property that identifies the type of the exception
    * `message` property
* Can also add other properties    

* Exception object will be delivered to the `catch` clause of a `try` statement
* A `try` statement has a single `catch` block will catch all exceptions
* Inspect the `name` to determine the type of the exception

## 4.11 Augmenting Types
* JavaScript allows the basic types of the language to be *augmented*
* By augmenting `Function.prototype`, we can make a method available to all functions
```
Function.prototype.method = function (name, func) {
    this.prototype[name] = func;
    return this;
};

Number.method('integer', function() {
    return Math[this < 0 ? 'ceiling' : 'floor'](this);
});
```

## 4.12 Recursion
* A *recursive* function is a function that calls itself, either directly or indirectly
* Recursion is a powerful programming technique in which a problem is divided into a set of similar subproblems, each solved with a trivial solution

## 4.13 Scope
* *Scope* in a programming language controls the visibility and lifetimes of variables and parameters
* Reduces naming collisions and provides automatic memory management
* Best to declare all of the variables used in a function at the top of the function body

## 4.14 Closure
* Inner function get access to the parameters and variables of the functions they are defined within (except for `this` and `arguments`)
```
var myObject = function () {
    var value = 0;
    
    return {
        increment: function(inc) {
            value += typeof inc === 'number' ? inc : 1;
        },
        
        getValue: function() {
            return value;
        }
    };
}();
```
* *Closure* function has access to the context in which it was created

## 4.15 Callbacks

## 4.16 Module
* Use functions and closure to make modules
* A module is a function or object that presents an interface but that hides its state and implementation
* The general pattern of a module is a function that defines private variables and functions; creates privileged functions which, through closure, will have access to the private variables and functions; and that returns the the privileged functions or stores them in an accessible place

## 4.17 Cascade
* If methods return `this` instead of `undefined`, we can enable `cascades`
* Cascading can produce interfaces that are very expressive
* It can help control the tendency to make interfaces that try to do too much at once

## 4.18 Curry
* *Curry* allows us to produce a new function by combining a function and an argument
```
Function.method('curry', function() {
    var slice = Array.prototype.slice,
        args = slice.apply(arguments),
        that = this;
    return function () {
        return that.apply(null, args.concat(slice.apply(arguments)));
    };
});
```

## 4.19 Memoization
* Functions can use objects to remember the results of previous operations, making it possible to avoid unnecessary work
```
var fibonacci = function() {
    var memo = [0, 1];
    var fib = function (n) {
        var result = memo[n];
        if (typeof result !== 'number') {
            result = fib(n - 1) + fib(n - 2);
            memo[n] = result;
        }
        return result;
    }
    
    return fib;
}();
```

* Generalize
```
var memoizer = function (memo, fundamental) {
    var shell = function (n) {
        var result = memo[n];
        if (typeof result !=== 'number') {
            result = fundamental(shell, n);
            memo[n] = result;
        }
        return result;
    };
    return shell;
}

var fibonacci = memoizer([0, 1], function(shell, n) {
    return shell(n - 1) + shell(n - 2);
});

var factorial = memoizer([1, 1], function(shell, n) {
    return n * shell(n - 1);
});
```
