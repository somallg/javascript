# 12. Developing cross-browser strategies 
* Attributes are an integral part of how the DOM get built
* Properties are the primary means by which elements hold runtime information, and by which this information can be accessed

## 12.1 DOM attributes and properties
* 2 options to accessing value of element attributes
    * Using DOM methods `getAttribute` and `setAttribute`
    * Using properties of the DOM objects that correspond to the attributes
```
e.getAttribute('id')
e.id
```
* Attribute and corresponding property, while linked, aren't always identical

### 12.1.1 Cross-browser naming
* When it comes to naming of attributes and their corresponding properties, property names are generally more consistent from browser to browser

### 12.1.2 Naming restrictions
* Attributes, being represented by strings passed to DOM methods, can be named with a rather free reign
* Property names, which can be referenced as identifiers using the dot operator notation, are more restricted, as they must conform to the rules for identifiers, and there are some reserved words that are disallowed

### 12.1.3 Differences between XML and HTML
* When dealing with XML DOM, no properties are automatically created on the elements to represent attribute values

### 12.1.4 Behavior of custom attributes
* Not all attributes are represented by element properties
* To access value of a custom attribute, we need to use the DOM methods `getAttribute()` and `setAttribute()`

### 12.1.5 Performance considerations
* In general, property access is faster than the corresponding DOM attribute methods

## 12.2 Cross-browser attribute issues

### 12.2.1 DOM id/name expansion

### 12.2.2 URL normalization
* When accessing a property that references a URL the URL value is automatically converted from its original form into a full canonical URL

### 12.2.3 The style attribute
```
getAttribute('style')
element.style.cssText
```

### 12.2.4 The type attribute
* Workaround
    * Create a new `<input>` element, copy over all properties and attributes, replace the original element with the newly created element
    * Reject any attempts to change the `type` element
    
### 12.2.5 The tab index problem

### 12.2.6 Node names
* Node names changes depending upon which type of document you're examining
* Solution is to normalize the name prior to any comparison

## 12.3 Styling attribute headaches

### 12.3.1 Where are my styles?
* Inline and assigned styles are recorded, but inherited styles aren't

### 12.3.2 Style property naming

### 12.3.3 The float style property
* `float` is reserved keyword in JavaScript

### 12.3.4 Conversion of pixel values

### 12.3.5 Measuring heights and widths
* Make a hidden element not hidden without making it visible
    * Change the `display` property to `block`
    * Set `visibility` to `hidden`
    * Set `position` to `absolute`
    * Grab the dimension values
    * Restore the changed properties

### 12.3.6 Seeing through opacity
* Browsers that support `opacity` will always normalize an opacity value less than 1.0 with a leading 0

### 12.3.7 Riding the color wheel

## 12.4 Fetching computed styles
* *computed style* of an element is a combination of all the styles applied to it via style sheets, the element's `style` attribute, and any manipulations of the `style` property by script
```
window.getComputedStyle
```

## 12.5 Summary
* Attributes *values* are set from the attributes placed on the element markup
* When retrieved, the attribute values may represent the same values, but they may sometimes be formatted differently than specified in the original markup
* Properties that represent the attribute values are created on the elements
* The keys for these properties may vary from the original attribute name, as well as across browsers, and the values may be formatted differently from either the attribute value or original markup
* When push comes to shove, we can retrieve the original markup value by diving into the original attributes nodes in the DOM and getting the value from them
* Dealing with properties is usually more performant than using the DOM attribute methods
* Versions of IE prior to IE 9 don't allow the `type` attribute of `<input>` elements to be changed once the elements is part of the DOME
* The `style` attribute poses some unique challenges and doesn't contain the computed value for the element
* Computed styles can be fetched from the `window` using a standardized API in modern browsers, and via a proprietary property in IE 8 and earlier