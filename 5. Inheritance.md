# 5. Inheritance
* In classical languages (Java(, inheritance (or *extends*) provide 2 useful services
    * Code reuse
    * Includes the specification of a system of types
    
* JavaScript, being a loosely typed language, never casts. What matters about an object is what it can do, not what it is descended from

* In classical languages, objects are instances of classes, and class can inherit from another class
* JavaScript is a prototypal language, which means that objects inherit directly from other objects

## 5.1 Pseudoclassical
* The `prototype` object is the place where inherited traits are to be deposited

* The classically inspired notation can induce programmers to compose hierarchies that are unnecessarily deep and complicated
* Much of the complexity of class hierarchies is motivated by the constrains of static type checking

## 5.2 Object Specifiers
* Difficult to remember the order of the arguments if constructor is given a large number of parameters
* Much friendlier if we write the constructor to accept a single object specifier instead
* Benefit of working with JSON

## 5.3 Prototypal
* Focus on objects 
* Prototypal inheritance is conceptually simpler than classical inheritance: a new object can inherit the properties of an old object
* The classification process of breaking an application down into a set of nested abstract classes can be completely avoided
```
var myMammal = {
    name: 'Herb',
    getName: function() {
        return this.name;
    },
    says: function() {
        return this.saying || '';
    }
};
```

* Make more instances with `Object.create`
```
var myCat = Object.create(myMammal);
myCat.name = 'Henrietta';
myCat.saying = 'meow';
myCat.purr = function (n) {
    var i, s = '';
    for (i = 0; i < n; i += 1) {
        if (s) {
            s += '-';
        }
        s += 'r';
    }
    return s;
};
myCat.getName = function() {
    return this.says() + ' ' + this.name + ' ' + this.says();
}
```
* This is *differential inheritance* - by customizing a new object, we specify the differences from the object on which it is based

## 5.4 Functional
* One weakness of the inheritance patterns we have seen so far is that we get no privacy
* Solution : make a function that will produce objects in 4 steps
    * Creates a new object
    * Defines private instance variables and methods
    * Augments that new object with methods
    * Return that new object
```
var constructor = function(spec, my) {
    var that, other private instance variables;
    my = my || {};
    
    Add shared variables and functions to my
    
    that = a new object;
    
    Add privileged methods to that
    
    return that;
}
```
* Apply this pattern to our mammal example
```
var mammal = function(spec) {
    var that = {};
    
    that.getName = function() {
        return spec.name;
    };
    
    that.says = function() {
        return spec.saying || '';
    };
    
    return that;
}

var myMammal = mammal({name: 'Herb'});

var cat = function(spec) {
    spec.saying = spec.saying || 'meow';
    
    var that = mammal(spec);
    
    that.purr = function() {
        var i, s = '';
        for (i = 0; i < n; i += 1) {
            if (s) {
                s += '-';
            }
            s += 'r';
        }
        return s;
    };
    
    that.getName = function() {
        return this.says() + ' ' + this.name + ' ' + this.says();
    };
    
    return that;
}
```
    
* If we create an object in the functional style, and if all of the methods of the object make no use of `this` or `that, the the object is `durable`
* A durable object is simply a collection of functions that act as *capabilities*

## 5.5 Parts
* We can compose objects out of sets of parts